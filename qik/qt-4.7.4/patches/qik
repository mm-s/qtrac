Index: qt-everywhere-opensource-src-4.7.4/src/corelib/global/qik.cpp
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/src/corelib/global/qik.cpp
@@ -0,0 +1,173 @@
+#include "qik.h"
+#include <stdio.h>
+#include <QThread>
+#include <Qtrac>
+#include <QSettings>
+#include <sstream>
+#include <iostream>
+#include <QProcessEnvironment>
+
+using namespace qtrac;
+using namespace std;
+
+typedef qtrac::qik c;
+
+c _qik_instance;
+
+c::qik():debug(0) {
+	QProcessEnvironment env=QProcessEnvironment::systemEnvironment();
+	if (env.contains(QString::fromLatin1("QTRAC_DEBUG"))) {
+		debug=new QFile("qtrac.log");
+	}
+	if (!env.contains(QString::fromLatin1("QTRAC_NOBANNER"))) {
+		qtrac::banner(stdout);
+	}
+
+	QSettings settings(QString::fromLatin1("Qtrac"), QString::fromLatin1("qik"));
+	{
+		if (env.contains(QString::fromLatin1("QTRAC_OUTPUT_FILENAME"))) {
+			output_filename=env.value(QString::fromLatin1("QTRAC_OUTPUT_FILENAME"));
+		}
+		else {
+			if (!settings.contains(QString::fromLatin1("output/filename")))
+				settings.setValue(QString::fromLatin1("output/filename"), QString::fromLatin1("qtrac.out")); //file
+
+			output_filename=settings.value(QString::fromLatin1("output/filename")).toString();
+		}
+		if (debug) cout << "output_filename=" << output_filename.toStdString() << endl;
+	}
+
+	QString output_socket;
+	{
+		if (env.contains(QString::fromLatin1("QTRAC_OUTPUT_SOCKET"))) {
+			output_socket=env.value(QString::fromLatin1("QTRAC_OUTPUT_SOCKET"));
+		}
+		else {
+			if (!settings.contains(QString::fromLatin1("output/socket")))
+				settings.setValue(QString::fromLatin1("output/socket"), QString::fromLatin1(""));
+			output_socket=settings.value(QString::fromLatin1("output/socket")).toString();
+		}
+		if (debug) cout << "output_socket=" << output_socket.toStdString() << endl;
+	}
+
+
+	if (debug) {
+		QHash<QString, QVariant> hash;
+		const QStringList keys = settings->allKeys();
+		Q_FOREACH(QString key, keys) {
+		  hash[key] = settings->value(key());
+		}
+	}
+
+	connect_socket();
+
+/*
+	if (!output_socket.empty()) {
+   QByteArray data; // <-- fill with data
+
+    _pSocket = new QTcpSocket( this );
+    connect( _pSocket, SIGNAL(readyRead()), SLOT(readTcpData()) );
+
+    _pSocket->connectToHost("127.0.0.1", 9000);
+    if( _pSocket->waitForConnected() ) {
+        _pSocket->write( data );
+    }
+	}
+*/
+}
+
+c::~qik() {
+	delete debug;
+}
+
+qik& c::instance() {
+	return _qik_instance;
+}
+
+void c::log(string data, void* sender, void* receiver) { //data is "s QFileSystemWatcher::fileChanged(1) io/qfilesystemwatcher.h:71"
+//todo sync threads
+	Qt::HANDLE tid=QThread::currentThreadId();
+	ostringstream os;
+	os << tid << " " << sender << " " << receiver << " " << data << endl;
+//"<tid> <sender> <receiver> s QFileSystemWatcher::fileChanged(1) io/qfilesystemwatcher.h:71"
+	if (sockfd==0) return;
+	string sbuff=os.str();
+	const char* p=sbuff.c_str();
+    int tot=sbuff.size();
+	while(tot>0) {
+		int n=write(sockfd,p,tot);
+		if (n < 0)  {
+		     error("ERROR writing to socket");
+			 return;
+		}
+		tot-=n;
+		p+=n;
+	}
+/*
+    bzero(buffer,256);
+    n = read(sockfd,buffer,255);
+    if (n < 0)
+         error("ERROR reading from socket");
+    printf("%s\n",buffer);
+    return 0;
+*/
+
+}
+
+void c::read_conf() {
+
+}
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+void c::error(string err) {
+	if (!debug) return;
+
+}
+
+void c::connect_socket() {
+
+    struct sockaddr_in serv_addr;
+    struct hostent *server;
+
+    char buffer[256];
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd < 0) {
+        error("ERROR opening socket");
+		sockfd=0;
+		return;
+	}
+    server = gethostbyname(host.constData());
+    if (server == 0) {
+	    close(sockfd);
+		sockfd=0;
+        error("no such host");
+        return;
+    }
+    bzero((char *) &serv_addr, sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length);
+    serv_addr.sin_port = htons(port);
+    if (connect(sockfd,(struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0) {
+	    close(sockfd);
+		sockfd=0;
+        error("ERROR connecting");
+		return;
+	}
+
+}
+
+void c::disconnect() {
+	if (sockfd==0) return;
+    close(sockfd);
+	sockfd=0;
+}
+
+
+
Index: qt-everywhere-opensource-src-4.7.4/src/corelib/global/qik.h
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/src/corelib/global/qik.h
@@ -0,0 +1,35 @@
+#ifndef QTRAC_QIK
+#define QTRAC_QIK
+
+#include <string>
+#include <QtCore/qglobal.h>
+#include <QFile>
+
+namespace qtrac {
+using namespace std;
+
+class Q_CORE_EXPORT qik {
+public:
+	qik();
+	~qik();
+
+	void log(std::string data, void* sender, void* receiver);
+	static qik& instance();
+
+private:
+	void read_conf();
+	void connect_socket();
+	void disconnect();
+	void error(string err);
+
+	QFile* debug;
+	QString output_filename;
+	int port;
+	QString host;
+	int sockfd;
+};
+
+
+}
+
+#endif
Index: qt-everywhere-opensource-src-4.7.4/include/QtCore/Qtrac
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/include/QtCore/Qtrac
@@ -0,0 +1,2 @@
+#include "qtrac.h"
+
Index: qt-everywhere-opensource-src-4.7.4/include/QtCore/qtrac.h
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/include/QtCore/qtrac.h
@@ -0,0 +1,3 @@
+#include "../../src/corelib/global/qik.h"
+#include "../../src/corelib/global/qtrac.h"
+
Index: qt-everywhere-opensource-src-4.7.4/include/QtCore/qtrac_bootstrap.h
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/include/QtCore/qtrac_bootstrap.h
@@ -0,0 +1,2 @@
+#include "../../src/corelib/global/qtrac.h"
+
Index: qt-everywhere-opensource-src-4.7.4/src/corelib/global/qtrac.cpp
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/src/corelib/global/qtrac.cpp
@@ -0,0 +1,32 @@
+#include "qtrac.h"
+
+void qtrac::banner(FILE* out) {
+fprintf(out, ".                                                                                .\n");
+fprintf(out, ".                                      >WWw,                                     .\n");
+fprintf(out, ".                                       `)WWW                                    .\n");
+fprintf(out, ".                                         )8WWu                ,uwu,             .\n");
+fprintf(out, ".                                          88WWWu            yWWWWWWWW,          .\n");
+fprintf(out, ".                                           `8WWWWwu,       8#WWWWWWWW`          .\n");
+fprintf(out, ".                                             '8WWWWWWWWwwwWWWWWWWWW*`           .\n");
+fprintf(out, ".                                               `8WWWWWWWWWWWWWWWW*`             .\n");
+fprintf(out, ".                                                ##WWWWWWWWWWWW*`                .\n");
+fprintf(out, ".   ,,,ywu                                     y#WWWWWWWWWWWWWWWWWWWWWWWwwuuywwW>.\n");
+fprintf(out, ".WWWWWWWWWWWWWWWWWWwu,                       ,&#WWWWWWWWWWWWWWWWW==WWWWW=====**^ .\n");
+fprintf(out, ". `^***====WWWWWWWWWWWWWWwwu,,,,uwWWWWWWw,,uWWWWWWWWWWWWWWWWW`                   .\n");
+fprintf(out, ".            `*===WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW                     .\n");
+fprintf(out, ".                 `=WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW*`                      .\n");
+fprintf(out, ".                    `*==WWWWWWWWWWWWWWWWWWWWWWWWWWWW*`                          .\n");
+fprintf(out, ".                        `*==WWWWWWWWWWWWWWWWWWWW=*`                             .\n");
+fprintf(out, ".                             ^*===WWWWWWWWWW=*`                                 .\n");
+fprintf(out, ".                    .d88888b.  888                                              .\n");
+fprintf(out, ".                   d88P' 'Y88b 888                                              .\n");
+fprintf(out, ".                   888     888 888                                              .\n");
+fprintf(out, ".                   888     888 888888 888d888 8888b.   .d8888b                  .\n");
+fprintf(out, ".                   888     888 888    888P'      '88b d88P'                     .\n");
+fprintf(out, ".                   888 Y8b 888 888    888    .d888888 888                       .\n");
+fprintf(out, ".                   Y88b.Y8b88P Y88b.  888    888  888 Y88b.                     .\n");
+fprintf(out, ".                    'Y888888'   'Y888 888    'Y888888  'Y8888P                  .\n");
+fprintf(out, ".                          Y8b                                                   .\n");
+fprintf(out, ".                                                                                .\n");
+}
+
Index: qt-everywhere-opensource-src-4.7.4/src/corelib/global/qtrac.h
===================================================================
--- /dev/null
+++ qt-everywhere-opensource-src-4.7.4/src/corelib/global/qtrac.h
@@ -0,0 +1,17 @@
+#ifndef QTRAC_QTRAC
+#define QTRAC_QTRAC
+
+#include <string>
+#include <cstdio>
+#include <QtCore/qglobal.h>
+
+namespace qtrac {
+
+void Q_CORE_EXPORT banner(FILE*);
+
+
+}
+
+#endif
+
+
 
